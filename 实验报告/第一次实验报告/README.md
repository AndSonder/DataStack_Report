<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

## 一、实验目的

1. 链表的基本操作

2. 链表的算法设计

3. 链表的应用

## 二、实验内容

1. 链表插入算法

2. 链表的删除算法

3. 移动链表中的最大值到尾部

4. 合并两个递增有序的单循环链表

5. 链表中奇偶结点的移动

6. 多项式的加法

## 三、实验环境

在PTA平台中进行实验

## 四、实验要求

根据每个实训的要求完成代码提交和评测

## 五、实验步骤

### 1. 链表的插入算法

**读题：**

*链表的定义：按照我的理解就是将不同位于不同地址的元素通过指针链接起来，所以叫做链表。

*链表进行插入：第一印象就是链表指针的断开与重建。

**思考：**

*在插入新元素的过程中吗，指针断裂的顺序应该是怎么样的呢？应该是先让新结点连接上后面的结点，然后再将原来的链接断开，让q->next = p;

*在插入的过程中会不会有不同的情况？比如头部插入，中间插入和尾部插入。我第一次写的时候为了处理这3种情况卡了好久。

**实现：**

*在链表的插入算法中主要需要考虑三种情况：1. 头部插入 2. 中间插入 3. 尾部插入

*头部插入的时候需要移动头结点；中间插入的时候注意新建的结点需要先连接后面再连接前面的。尾部插入的时候直接连接到前面的结点就行。

### 2. 链表的删除算法

**读题：**

*删除的第一印象就是比插入简单，不就是删除吗。直接p->next = p->next->next不就好了吗？但是如果这样做的话其实会出现很多问题。

**思考：**

*如何良好的处理，头部，中部删除和尾部删除呢，如果使用单指针指针遍历的话就会出现奇奇怪怪的问题，因为p->next->next一旦处理不好就会产生越界问题？

*有没有一个好一些的方法可以处理这个问题呢？后面经过课堂的学习知道了还有用两个指针同时遍历的操作。

**实现：**

*本题我在做实验的过程中都是使用单指针遍历的方式，这种方式在删头，删中间，删尾部的时候都需要做不同的处理且处理方式相对麻烦。于是后面在经过课上的学习后我才用了双指针遍历的方式。两个指针一前一后这样在处理过程中就方便很多。在删除之后还需要将删除的那个结点的内存进行释放。

### 3. 移动链表最小值到尾部

**读题：**

*移动最小值到尾部，那么应该就要涉及两个步骤。也就是找到最小值和移动最小值到尾部。实现这两个步骤应该就可以了。

**思路：**

*如何找到最小值？可以用一个变量进行存储，然后遍历一遍链表获取到最小值；

*如何将最小值移动到尾部呢？应该要涉及两个步骤，一个是讲原来的最小值删除，第二个就是在尾部添加一个

**实现：**

*先通过一次遍历找出链表中的最小值，然后再第二次的遍历过程中将原来的最大值结点删除然后移动到尾部。在删除的过程中需要判断最大值是否已经在尾部了，如果已经在尾部则不需要进行操作。

*在实现的过程中也踩了很多坑，比如一开始没有考虑到最小值就是在尾部的情况，导致程序报错了很久。

**优化：**

*在第一次遍历的过程中保存最小值所在位置的指针位置，最小值的前一个所在的指针位置（链表有头节点）还有最后一个结点的指针。这样在第二步进行删除最小值和插入尾部的过程中就不需要重新进行一次遍历了。

### 4. 合并两个递增有序的单循环链表

**读题：**

*首先题目没有规定不能创建一个新的循环链表，所以一开始想的是再新建一个，之后分别遍历一下两个链表将元素插入到其中。

*当然应该可以不新建立一个链表，在原有链表的基础上应该也可以完成要求。

**思考：**

*第一种实现方式太暴力了，这里就不思考了。想要实现在原有链表上进行修改，我们需要有两个指针分别指向两个链表。

*两个指针要怎么移动呢？因为两个链表都是有序的，所有就不需要有那么多的顾虑。使用双重for循环应该可以解决问题。

**实现：**

*对于本题需要首先定义两个分别指向两个循环链表的结构体指针。在遍历过程中将通过比较大小的方式将第二个链表中的数值依次加入第一个链表当中。本题需要注的点为单循环链表的遍历方式采用do-while循环的方式会很简单。使用while或者for循环的方式就会很麻烦。

### 5. 链表中奇偶结点的移动

**读题：**

*链表奇偶移动，我的理解就是将原本的奇数结点放在一块。这还不简单吗？又想到了暴力的方法，直接新建一个链表然后遍历两次就不可以了吗？

**思考：**

*有没有更简单的方法可以实现这到题目呢？直接新建一个链表总感觉太暴力了，直接不带脑子写了。所以我又在力扣中找到了一种很巧妙的方法。

**实现：**

*此题我使用了两种方法实现：

1. 创建一个新的链表，将奇数和偶数分别的添加进去（简单的方法）

2. 迭代的算法，参考力扣中题目的解法

   - `p0`指奇数节点，`p1`指偶数节点，`p1`一定比`p0`先到达链表尾部
   - 内存地址`head`始终不变，`head.next`在第一次迭代中被更改。用`n`存初始`head.next`（第一个偶数）内存地址
   - 每次取出上次`p0`（奇数）和`p1`（偶数），分别指向当前位置奇数和偶数，迭代结束后
   - `p0`刚好指向最后一个奇数，第一个偶数内存地址在`n`，两者相连即可

   代码：

   ```c
   var oddEvenList = function(head) {
    if (head && head.next) {
           var p = [head, head.next], n = p[1]
           while (p[1] && p[1].next) {
               p[0].next = p[0].next.next
               p[1].next = p[1].next.next
               p = [p[0].next, p[1].next]
           }
           p[0].next = n
       }
       return head
   };
   ```

### 6. 多项式的加法

输入在第一行给出第一个多项式POLYA的系数和指数，并以0,0 结束第一个多项式的输入；在第二行出第一个多项式POLYB的系数和指数，并以0,0 结束第一个多项式的输入。

**读题：**

*本题需要做一个多项式的加法。首先拿到题目之后想到的就是使用两个链表来存储输入的信息。接下来需要考虑的就是如何进行数据的处理让两个“多项式链表”可以加起来。

**思考：**

*应该如何对两个多项式链表进行遍历以达到加法效果呢？一开始尝试的是暴力的双重for循环，但是这种方法不仅会出现各种各样的问题，时间复杂度还比较高。

*仔细思考之后发现，其实只需要一个while循环就可以实现要求。但是需要对p和q往后遍历的条件需要做比较仔细的设计。

**实现和踩坑：**

*如何存储多项式的系数和次方数呢？-》 使用结构体存储

*如果输入的指数没有按照升序排列需要对链表进行排序，否则会导致算法错误。

*在合并的时候考虑指数缺少，大于，小于的三种情况如何处理。假设我们是在第一个链表的基础上进行多项式加法，如果第一个链表中不存在第二个链表中的指数就需要添加，下面具体的介绍一下排序和合并实现。

#### 排序

在本次的实验中排序算法我选择了冒泡排序的算法。在创建节点结构体时我给这个节点添加了一个长度的值length。在给链表添加元素的过程中让length递增来计算链表的长度。这样在实现冒泡排序的过程中就可以使用双重for循环来进行排序。因为循环的次数可以用长度来确定

#### 合并

在合并的过程中很重要的一点为引入两个指针分别指向两条链表，这样在遍历的过程中就不需要双重for循环进行遍历。其实我一开始就是使用的双重for循环遍历的暴力方法。之后又参考了书上的内容使用了单while循环加多重判断的方法。多重判断的注意要点如下：

假设p指向第一个链表，q指向第二个链表则：

- 当`p->exp < q->exp`的时候，说明第二条链表的次数已经高于第一条，此时需要将p的指向向着后面移动；
- 当`p->exp == q->exp`的时候，所有指数相同此时进行指数相加；
- 当`p->exp > q->exp`的时候，说明第一条链表中没有q指向结点次数的项，需要把此时q指向的结点添加进p当中；

## 六、实验总结

本次实验中，我掌握了链表的插入，删除等应用。在课程的学习过程中又了解了很多链表算法的改进。下面对我认为链表中比较高级的算法进行总结。

### 1. 链表中的双指针删除算法

链表普通的删除算法使用结点去遍历链表，但是这样的方法的问题是在删除中部和删除尾部时还需要做特殊的判断，导致代码比较复杂。使用双指针的算法可以在删除结点时不需要考虑遍历到尾部时双重next会输出超出链表长度的情况。

<img src="%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/%E6%88%AA%E5%B1%8F2020-10-21%20%E4%B8%8B%E5%8D%888.11.37.png" alt="截屏2020-10-21 下午8.11.37" style="zoom:67%;" />

### 2.头结点的妙用

在创建链表的时候我常常就把头结点单纯的作为一个指向链表头的一个指针来使用，但其实链表头如果可以妙用用处还是很多的。比如可以在头结点中存储链表的长度或者一些其他信息。举一个例子，如果链表头中存储了链表的长度，在对链表进行冒泡排序时就可以通过双重for循环进行，因为循环的次数已经确定了。

<img src="%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/%E6%88%AA%E5%B1%8F2020-10-21%20%E4%B8%8B%E5%8D%888.16.39.png" alt="截屏2020-10-21 下午8.16.39" style="zoom: 67%;" />

### 3.双指针遍历双链表完成合并功能

在合并两条链表的时候往往需要遍历两个链表，这个时候往往有两个方法，一种是暴力的算法，新建一个链表根据自己的需要添加。一种是在原有链表的基础上进行修改。

以下图进行说明：

<img src="%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C.assets/%E6%88%AA%E5%B1%8F2020-10-21%20%E4%B8%8B%E5%8D%888.41.41.png" alt="截屏2020-10-21 下午8.41.41" style="zoom:67%;" />

假设需要把p2指向的链表合并入p1所指向的链表，合并不一定是单纯的首位拼接。多项式加法也是合并方式的一种。在合并的过程中p2指针先行。p1指针根据p2指针移动的情况前行。

















