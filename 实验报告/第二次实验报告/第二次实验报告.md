## 一、实验目的

1. 掌握栈和队列的基本操作

2. 栈和队列的算法设计

3. 栈和队列的应用

4. 递归

## 二、实验内容

1. 循环队列

2. 进制转换

3. 迷宫-深度策略

4. 迷宫-广度策略

5. 农夫过河-广度策略
6. “聪明的学生”

## 三、实验环境

在PTA平台进行实验

## 四、实验要求

根据每个实训的要求完成代码提交和测评

## 五、实验步骤

### 5.1 循环队列

本题要求实现队列的顺序存储表示，包括入队、出队和取队头操作

#### 1. 入队

尾部入队，尾部指针后移一位。

#### 2. 出对

头部出队，头部指针后移一位。

#### 3. 取队头

输出头指针指向的值。

### 5.2 进制转换

**问题描述**：本题要求实现十进制到十六进制的转换，用户输入10进制的数，要求输出该数的16进制表示。

进制转化的方法为得到各个位的余数，然后再将余倒序输出。符合`先进后出`的特点。故使用栈的结构可以很好的解决本题。以6举例，在计算求的余数后将其压入栈中，然后在让其以此出栈便可得到二进制转化后的结果。

![image-20201121115833900](%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20201121115833900.png)

### 5.3 迷宫-深度策略

**问题描述：**一个陷入迷宫的老鼠如何找到出口的问题。老鼠希望系统性地尝试所有的路径之后走出迷宫。如果它到达一个死胡同，将原路返回到上一个位置，尝试新的路径。在每个位置上老鼠可以向八个方向运动：东、南、西、北、东南、东北、西南和西北。无论离出口多远，它总是按照这样的顺序尝试，当到达一个死胡同之后，老鼠将进行“回溯”。迷宫只有一个入口，一个出口，设计程序要求输出迷宫的一条通路。迷宫用二维存储结构表示，1表示障碍，0表示通路；采用回溯法设计求解通路的算法。要求如下： 1、实现栈的相关操作； 2、利用栈实现回溯算法输出路径。

#### 题目分析：

本题要求采用深度策略求解迷宫问题，老鼠在探索道路的过程中一旦有可走的道路就直接前进。如果前进到死胡同当中便返回直到找到正确的通路。本题采用的搜索顺序为： 下，右下，右，右上，上，左上，左，左下的顺序。并对走过的迷宫加上标示。在进行搜索代码的编写中需要注意一下几点：

- 使用栈存储路线信息，如果存在回退的情况。回退的过程符合栈后进先出的概念。
- 走过的迷宫使用数组存储其是否走过的信息。

### 5.4 迷宫-广度策略

#### 题目分析：

本题的题目与上一题相同，但是要求需要使用广度策略进行书写。广度策略与深度策略不同，在前进的过程中会尝试所有可能存在情况。并将每一种情况推入到队列当中。同时广度搜索策略搜索到的是**最短路径**。在编写广度搜索的代码过程中需要注意一下几点：

- 在进行的搜索中对8个方向都进行搜索
- 在搜索的过程中只有没有走过的通路才会被推入队列当中。
- 有两个数组preposX和preposY用来储存该节点的的上一个结点上是什么。否则将丢失搜索的路径。 

### 5.5 农夫过河-广度策略

**问题描述：**一个农夫带着一只狼、一只羊和一棵白菜，身处河的南岸。他要把这些东西全部运到北岸。遗憾的是他只有一只小船，小船只能容下他和一件物品。这里只能是农夫来撑船。同时因为狼吃羊，而羊吃白菜，所以农夫不能留下羊和狼或者羊和白菜单独在河的一边，自己离开。好在狼属于肉食动物，不吃白菜。农夫怎样才能把所有的东西安全运过河呢？ 为了表示每个物品的位置，采用二进制位来区分南岸和北岸，0表示在南岸，1表示在北岸。用四个二进制位XXXX分别表示农夫、狼、菜和羊四个物品所在的位置。例如1110表示农夫、狼和菜在北岸，菜在南岸。农夫过河问题的初始状态为0000，结束状态为1111。

#### 题目分析：

本题为利用广度策略去搜索农夫过河的策略。主要思路与迷宫的广度搜索策略相同。唯一一点不同的是迷宫判断是道路是否可行，而农夫过河问题中是是否可以带过去。在本题的求解过程中很巧妙的运用了`&`运算符来判断接下来的状态是否安全。本题要点有如下几点：

- 使用编码的格式确定各物体的状态，农夫在右边表示为0x08，狼在右边表示为0x04，大白菜在右边表示为0x02，羊在右边表示为0x01，也就是对于 1000，0100，0010，0001四个二进制编码。这也是在机器学习数据预处理阶段常用的**独热编码**。
- 通过几个编码的组合便**可以确定农夫和其他动物的位置情况**。比如1100就表示农夫和狼在右边而羊和大白菜在左边。还可以用来**确认哪几个需要移动**。
- 状态的翻转：状态的翻转可以通过使用异或运算来实现。

### 5.6 聪明的学生

**问题描述：**一位逻辑学的教授有三个非常聪明善于推理且精于心算的学生，Alice、Bob和Charles。一天教授给他们出了一个题。教授在每个人脑门上帖了一个纸条，每个纸条上写了一个正整数，Alice、Bob和Charles分别是3，5，8，并且告诉学生某两个数的和等于第三个，每个学生只能看见另外两个同学头上的正整数，但是看不见自己的。 教授问的顺序是Alice---Bob—Charles—Alice……经过几次提问后，当教授再次询问到Charles时，Charles露出了得意的笑容，准确的报出了自己头上的数。

#### 题目分析：

该题的关键点为分析出每个学生在听到上一个学生回答不是后可以得出的信息。**通过列举出学生会猜对的比例然后根据该比例是否与三个数字来判断改同学时候能否猜对。** 接下来以第一圈为例子进行分析。

到Alice猜到时候，能够让Alice猜中到情况只有Bob和Charles头上的数字相等这种情况。即比例为2:1:1，但是很明显不是这样的。

接下来轮到Bob猜，同样的Bob可以猜对的情况也有Alice和Charles头上的数字一样的这种情况。不同的是Bob通过Alice的回答可以确定自己头上的数字和Charles头上的数字不一样，要不刚才Alice就已经猜出来了。那么Bob可以猜对的情况又多了一种就是：2:3:1，因为自己头上数字肯定不可能和Charles头上的数字一样，如果比例为2:3:1 Bob就可以判断出自己头上的数字了。然而2:3:1也不符合3:5:8。所以Bob也不知道。

接下来轮到Charles猜，同样的，Charles可以猜对的情况有1:1:2这种，同时Charles通过Alice的回答知道了自己和Bob头上的数字不一样。通过Bob的回答也知道了自己和Alice头上的数字也不一样，同时还可以退出自己头上的数字不是Alice的两倍，否则Bob刚才就该猜出来了。所以Charles可以猜中的情况还有1:2:3、2:3:1、2:1:3以及2:3:5。

总而言之，每一个人回答的结果都可以被当作下一个人的先验知识。当采用递归的实现进行求解释，**递归的出口点就可以设置为大数减两个小数的差值为0.**

**现在问题可以转化为找出x1,|x1-x2|,x3 中第一个猜出数字的人所用的次数。这个问题不断地重复成一个子问题，不断的重复这个过程，直到学生可以猜出答案。**

整体递归函数如下：

```c
int times(int i,int j,int t1,int t2,int t3)
{
    int k = i-j;
    if (k == 0)
    {
        return t3;
    }
    else if (k>0)
    {
        return times(j,i-j,t2,t3,t1) + step(t1,t3);
    } else
        return times(i,j-i,t1,t3,t2) + step(t2,t3);
}
```

## 六、问题记录和实验总结

### 6.1 栈和队列

在本次实验中详细的了解了栈和队列的应用，并使用代码实现了栈和队列的创建，插入，删除等操作。下面对几个方法的实现过程进行总结。

#### 6.1.1 栈

以下图示的头节点均使用了一个头节点。不做线性栈的总结，只做链栈的总结。

**栈的入栈操作：**

![image-20201121115857070](%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20201121115857070.png)

当有节点需要入栈的时候首先让新的节点指向top的next，之后更新top的next即可。

**栈的出栈操作：**

![image-20201121115910621](%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20201121115910621.png)

当需要进行出栈的操作的时候只需要让先记住目前top的next然后在更新top的next，最后将节点free掉就可以了。

#### 6.1.2 队列

队列入队和出队的操作和栈比较类似，不过队列遵循的是**先进先出**的原则，而栈遵循的是**先进后出**的原则。

### 6.2 深度搜索与广度搜索

在学习了栈和队列后在本次实验中还对这两种结构进行了具体的应用，这两种应用分别是深度搜索和广度搜索。两种搜索算法分别灵活的应用了栈和队列的算法思想。

#### 6.2.1 深度搜索（DFS）

深度优先搜索算法（Depth-First-Search），是搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。

**深度搜索搜索的不是最短路径**，以迷宫举例其搜索方式大致如下：

从起点开始先将起点压入栈中，然后按照下，右下，右，右上，上，左上，左，左下的方向进行扫描。如果扫描到可以走到通路且改通路没有走过则将通路到坐标压入栈中，如果八个方向都不能满足条件则出栈，出栈在具体的迷宫行为上就表现为回退。一直搜索到终点时将路径从栈中全部弹出。

![image-20201121115919301](%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20201121115919301.png)

#### 6.2.2 广度搜索（BFS）

如果把DFS理解成一个人在走迷宫，则BFS理解为无数个人在同时走迷宫，他们走迷宫按照一定的策略，这个策略是，每次走之前，都把下一次可以走的路径记下来，每个人走不同的可能存在的路径，直到走到终点为止。DFS和BFS主要的区别在于DFS是按一条路走到黑（不撞南墙不回头）的原则去试探，而BFS是按层级去试探。在遍历的过程中会将所有的情况都推入队列当中，BFS寻找的**最优解**对应到迷宫问题中来也就是最短路径。但是同时这种算法也要开辟很大的内存。

### 6.3 独热编码在算法中的应用

在本次实验的农夫过河实验中通过对独热编码的应用灵活配合与和或非等运算解决了农夫过河问题。通过对不同种类的数据进行独热编码，通过二进制数值的形式去解决算法问题是一种很灵活的思路。除了农夫过河问题最近还遇到了一道类似思路的算法题目，下面通过对这道题目的解析进一步展示二进制编码（独热编码）在算法中的灵活运用。

**题目描述：**
lzh是个很热情的人，他决定参与学校的新书发放工作，学校的仓库里一共有m本书，每个新生需要n本不同种类的书才可以凑成一套完整的教材，已知这n本书的书名分别是1～n，lzh需要在这m本书里挑出成套的教材并把它们分给学生，但是他觉得这个工作太无聊啦，于是他推掉了工作并把这个问题写在了模拟题里，希望你能帮他解答一下。
**输入：**

第一行两个整数n，m代表一套教材需要的书的种类数，以及学校仓库里共有多少本书

第二行m个正整数，表示仓库里每一本书都是什么种类的，保证每个整数≤n
**输出：**

输出包含一个01序列，共m个字符，当第i个字符为1时代表到前i本书可以凑成一套教材，这时valtor需要把可以凑成一套教材的这些书取出来发给新生，然后继续凑下一套教材。

.![image-20201121115933232](%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20201121115933232.png)

本题也是运用了编码的思想，由于数的编号是从1开始的，令书的编号为2的(k-1次方)，假设m=3，则每个种类书编号的二进制表示就为001,010和100。那么题目中两个最关键的问题就可以这样表示：

- 如果表示已经拿了的书？

  使用一个变量g来储存，g为001表示有了编号为1的书，g为010表示有了标号为2的书，g为011表示有了编号为1和编号为2的书。当g为111时表示拿完了。
  
- 如果表示这本书是否拿过？

  将书的编号与g进行与运算 比如g & 001的结果如果为0就表示没有拿过编号为1的书？

- 如何更新g？

  如果这本书没拿过就需要更新g，那么就只需要加上2的k-1次方即可。





















































































